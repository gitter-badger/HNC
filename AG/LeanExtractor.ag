
ATTR Root
	[ | | leanDefinition USE {:} {[]} : {[String]} ]

ATTR ASTDefinition
	[ | | leanDefinition : String ]

ATTR ASTLetIn ASTExpression
	[ | | lean' : ASTExpression ]

ATTR ExpressionList [ | | lean' USE {:} {[]} : {[ASTExpression]} ]

SEM ASTDefinition
	| Definition
		lhs.leanDefinition = {
			"definition " ++ @name ++ leanTA (S.toList @loc.templateArgs) ++ (if @loc.isFunction
				then concat (zipWith fff @params $ leanArgs @loc.definitionType) ++ " : " ++ showT (leanRet @loc.definitionType)
				else  " : " ++ showT @loc.definitionType) ++ " := " ++ showE @where.lean'
		}

SEM ASTLetIn
	| In
		lhs.lean' = @value.lean'

SEM ASTExpression
	| Constant
		lhs.lean' = Constant @c
	| Atom
		lhs.lean' = Atom $ @name ++ showLeanArgs @loc.templateArgs
	| Application
		lhs.lean' = Application @fn.lean' @arg.lean'

{
extractLean def inh = showRoot $ leanDefinition_Syn_Root $ wrap_Root (sem_Root def) inh

fff var t = " " ++ inParens (var ++ " : " ++ showT t)

leanRet (TT l) = last l

leanArgs (TT l) = init l

leanTA x = concatMap (\x -> " " ++ inParens (x ++ " : *")) x

showRoot x = head x ++ "\n"

showLeanArgs x = concatMap f x where
	f (T x) = " " ++ x
	f x = " " ++ showT x

showT (TD a b) = a ++ " " ++ joinStr " " (map showT b)
showT (TT a) = joinStr " -> " (map showT a)
showT (T x) = x
showT (TU x) = x
showT (TV x) = x
showT x = show x
}
